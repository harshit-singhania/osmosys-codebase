## 1. Using await 

- Used for: Asynchronous execution without blocking the thread.
- Usage: Inside an async method.

Example:

```
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Before async call");
        await SomeAsyncMethod();
        Console.WriteLine("After async call");
    }

    static async Task SomeAsyncMethod()
    {
        await Task.Delay(2000); // Simulate async work
        Console.WriteLine("Async method completed");
    }
}
``` 

## 2. Using .Wait()

- Used for: Blocking execution in non-async contexts.
- Usage: Use Task.Wait() to block synchronously.

```
static void Main()
{
    Console.WriteLine("Before async call");
    SomeAsyncMethod().Wait();
    Console.WriteLine("After async call");
}
```

## 3. Using .GetAwaiter().GetResult()

- Best for: Avoiding AggregateException when handling exceptions.
- Usage: Similar to .Wait(), but throws actual exceptions.

```
static void Main()
{
    Console.WriteLine("Before async call");
    SomeAsyncMethod().GetAwaiter().GetResult();
    Console.WriteLine("After async call");
}
``` 


## 4. Using Task.Run().Result

- Used for: Blocking execution while keeping the main thread free.
- Usage: Runs the async method inside Task.Run().

```
static void Main()
{
    Console.WriteLine("Before async call");
    var result = Task.Run(() => SomeAsyncMethod()).Result;
    Console.WriteLine("After async call");
}
``` 


## 5. Using ContinueWith()

- Used for: Executing code after async method completion without blocking.
- Usage: Chain tasks with .ContinueWith().

```
static void Main()
{
    Console.WriteLine("Before async call");

    SomeAsyncMethod().ContinueWith(task =>
    {
        Console.WriteLine("Async method completed, now running ContinueWith");
    });

    Console.WriteLine("Main method continues...");
    Console.ReadLine(); // Prevents the program from exiting immediately
}
``` 
